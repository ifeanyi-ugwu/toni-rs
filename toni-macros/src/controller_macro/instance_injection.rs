//! Controller Instance Injection Implementation
//!
//! Architecture:
//! 1. User struct with REAL fields (unchanged)
//! 2. Controller wrapper per handler method that lazily creates instances with dependency resolution
//! 3. Manager that returns controller wrappers
//!
//! Example transformation:
//! ```rust,ignore
//! // User code:
//! #[controller_struct(pub struct AppController { service: AppService })]
//! #[controller("/api")]
//! impl AppController {
//!     #[get("/info")]
//!     fn get_info(&self, req: HttpRequest) -> ToniBody {
//!         self.service.get_app_info()
//!     }
//! }
//!
//! // Generated:
//! #[derive(Clone)]
//! pub struct AppController {
//!     service: AppService
//! }
//!
//! impl AppController {
//!     fn get_info(&self, req: HttpRequest) -> ToniBody {
//!         self.service.get_app_info()
//!     }
//! }
//!
//! struct GetInfoController {
//!     dependencies: FxHashMap<String, Arc<Box<dyn ProviderTrait>>>
//! }
//!
//! impl ControllerTrait for GetInfoController {
//!     async fn handle(&self, req: HttpRequest) -> HttpResponse {
//!         // Resolve dependencies
//!         let service: AppService = *self.dependencies.get("AppService")
//!             .unwrap().execute(vec![]).await.downcast().unwrap();
//!
//!         // Create controller instance with real fields
//!         let controller = AppController { service };
//!
//!         // Call user's method on real struct
//!         controller.get_info(req)
//!     }
//! }
//! ```

use proc_macro2::TokenStream;
use quote::quote;
use std::collections::HashMap;
use syn::{
    Attribute, Error, Ident, ImplItemFn, ItemImpl, ItemStruct, LitStr, Result, spanned::Spanned,
};

use crate::{
    enhancer::enhancer::create_enhancers_token_stream,
    markers_params::{
        extracts_marker_params::{
            extract_body_from_param, extract_path_param_from_param, extract_query_from_param,
        },
        get_marker_params::MarkerParam,
    },
    shared::{dependency_info::DependencyInfo, metadata_info::MetadataInfo},
    utils::controller_utils::{attr_to_string, create_extract_body_dto_token_stream},
};

pub fn generate_instance_controller_system(
    struct_attrs: &ItemStruct,
    impl_block: &ItemImpl,
    dependencies: &DependencyInfo,
    route_prefix: &str,
    scope: crate::shared::scope_parser::ControllerScope,
    was_explicit: bool,
) -> Result<TokenStream> {
    let struct_name = &struct_attrs.ident;

    // Add Clone derive to struct (required for creating instances)
    let struct_with_clone = add_clone_derive(struct_attrs);
    let impl_def = impl_block.clone();

    // OPTIMIZATION: Conditionally generate wrappers based on scope and dependencies
    // Goal: Only generate wrappers that could actually be used

    let (singleton_wrappers, singleton_metadata, request_wrappers, request_metadata) =
        match (scope, was_explicit) {
            // Case 1: Explicit Request scope - only generate Request wrappers
            // No auto-elevation possible (already Request), so Singleton wrappers are dead code
            (crate::shared::scope_parser::ControllerScope::Request, true) => {
                let (req_wrappers, req_meta) = generate_controller_wrappers(
                    impl_block,
                    struct_name,
                    dependencies,
                    route_prefix,
                    crate::shared::scope_parser::ControllerScope::Request,
                )?;
                (vec![], vec![], req_wrappers, req_meta) // Skip Singleton wrappers!
            }

            // Case 2: Explicit or default Singleton - might need elevation
            _ => {
                let (sing_wrappers, sing_meta) = generate_controller_wrappers(
                    impl_block,
                    struct_name,
                    dependencies,
                    route_prefix,
                    crate::shared::scope_parser::ControllerScope::Singleton,
                )?;

                // Sub-optimization: Skip Request wrappers if no dependencies
                let (req_wrappers, req_meta) = if dependencies.fields.is_empty() {
                    (vec![], vec![]) // No deps = no elevation possible
                } else {
                    generate_controller_wrappers(
                        impl_block,
                        struct_name,
                        dependencies,
                        route_prefix,
                        crate::shared::scope_parser::ControllerScope::Request,
                    )?
                };

                (sing_wrappers, sing_meta, req_wrappers, req_meta)
            }
        };

    let manager = generate_manager(
        struct_name,
        singleton_metadata,
        request_metadata,
        dependencies,
        scope,
        was_explicit,
    );

    Ok(quote! {
        #[allow(dead_code)]
        #struct_with_clone

        #[allow(dead_code)]
        #impl_def

        // Generate Singleton wrappers (always)
        #(#singleton_wrappers)*

        // Generate Request wrappers (only if controller has dependencies)
        #(#request_wrappers)*

        #manager
    })
}

fn add_clone_derive(struct_attrs: &ItemStruct) -> ItemStruct {
    let mut struct_def = struct_attrs.clone();

    let has_clone = struct_def.attrs.iter().any(|attr| {
        if attr.path().is_ident("derive") {
            // Would need to parse derive contents properly
            false
        } else {
            false
        }
    });

    if !has_clone {
        // Add both Clone and Injectable derives
        // Injectable registers #[inject] and #[default] as valid attributes
        let derives: syn::Attribute = syn::parse_quote! {
            #[derive(Clone, ::toni::Injectable)]
        };
        struct_def.attrs.push(derives);
    } else {
        // Just add Injectable
        let injectable_derive: syn::Attribute = syn::parse_quote! {
            #[derive(::toni::Injectable)]
        };
        struct_def.attrs.push(injectable_derive);
    }

    struct_def
}

fn generate_controller_wrappers(
    impl_block: &ItemImpl,
    struct_name: &Ident,
    dependencies: &DependencyInfo,
    route_prefix: &str,
    scope: crate::shared::scope_parser::ControllerScope,
) -> Result<(Vec<TokenStream>, Vec<MetadataInfo>)> {
    let mut wrappers = Vec::new();
    let mut metadata_list = Vec::new();

    // Extract controller-level enhancers from impl block attributes
    let controller_enhancers_attr = get_enhancers_attr(&impl_block.attrs)?;

    for item in &impl_block.items {
        if let syn::ImplItem::Fn(method) = item {
            if let Some(http_method_attr) = find_http_method_attr(&method.attrs) {
                let method_enhancers_attr = get_enhancers_attr(&method.attrs)?;

                let marker_params = get_marker_params(method)?;

                let (wrapper, metadata) = generate_controller_wrapper(
                    method,
                    struct_name,
                    dependencies,
                    route_prefix,
                    http_method_attr,
                    controller_enhancers_attr.clone(),
                    method_enhancers_attr,
                    marker_params,
                    scope,
                )?;

                wrappers.push(wrapper);
                metadata_list.push(metadata);
            }
        }
    }

    Ok((wrappers, metadata_list))
}

fn find_http_method_attr(attrs: &[Attribute]) -> Option<&Attribute> {
    attrs.iter().find(|attr| {
        attr.path().is_ident("get")
            || attr.path().is_ident("post")
            || attr.path().is_ident("put")
            || attr.path().is_ident("delete")
            || attr.path().is_ident("patch")
            || attr.path().is_ident("head")
            || attr.path().is_ident("options")
    })
}

fn get_enhancers_attr(attrs: &[syn::Attribute]) -> Result<HashMap<&Ident, &Attribute>> {
    use crate::enhancer::enhancer::get_enhancers_attr as get_enhancers;
    get_enhancers(attrs)
}

fn get_marker_params(method: &ImplItemFn) -> Result<Vec<MarkerParam>> {
    use crate::markers_params::get_marker_params::get_marker_params as get_params;
    get_params(method)
}

fn generate_controller_wrapper(
    method: &ImplItemFn,
    struct_name: &Ident,
    dependencies: &DependencyInfo,
    route_prefix: &str,
    http_method_attr: &Attribute,
    controller_enhancers_attr: HashMap<&Ident, &Attribute>,
    method_enhancers_attr: HashMap<&Ident, &Attribute>,
    marker_params: Vec<MarkerParam>,
    scope: crate::shared::scope_parser::ControllerScope,
) -> Result<(TokenStream, MetadataInfo)> {
    let http_method = attr_to_string(http_method_attr)
        .map_err(|_| Error::new(http_method_attr.span(), "Invalid attribute format"))?;

    let route_path = http_method_attr
        .parse_args::<LitStr>()
        .map_err(|_| Error::new(http_method_attr.span(), "Invalid attribute format"))?
        .value();

    let full_route_path = format!("{}{}", route_prefix, route_path);

    let method_name = &method.sig.ident;
    // Include struct name to avoid collisions between controllers with same method names
    // Also include scope suffix to allow both Singleton and Request wrappers
    let scope_suffix = match scope {
        crate::shared::scope_parser::ControllerScope::Singleton => "",
        crate::shared::scope_parser::ControllerScope::Request => "Request",
    };
    let controller_name = Ident::new(
        &format!(
            "{}{}Controller{}",
            struct_name,
            capitalize_first(method_name.to_string()),
            scope_suffix
        ),
        method_name.span(),
    );
    let controller_token = controller_name.to_string();

    let (field_resolutions, field_names) = generate_field_resolutions(dependencies);

    // Generate initializers for owned fields
    let owned_field_inits: Vec<_> = dependencies
        .owned_fields
        .iter()
        .map(|(field_name, field_type, default_expr)| {
            if let Some(expr) = default_expr {
                quote! { #field_name: #expr }
            } else {
                quote! { #field_name: <#field_type>::default() }
            }
        })
        .collect();

    let struct_instantiation = quote! {
        let controller = #struct_name {
            #(#field_names,)*  // Injected dependencies
            #(#owned_field_inits),*  // Owned fields with defaults
        };
    };

    let method_call = generate_method_call(method, &marker_params)?;
    let enhancers =
        create_enhancers_token_stream(controller_enhancers_attr, method_enhancers_attr)?;

    let (marker_params_extraction, body_dto_token_stream) =
        generate_marker_params_extraction(&marker_params)?;

    let wrapper = generate_controller_wrapper_code(
        &controller_name,
        &controller_token,
        &full_route_path,
        &http_method,
        &field_resolutions,
        &struct_instantiation,
        &method_call,
        &enhancers,
        &marker_params_extraction,
        &body_dto_token_stream,
        scope,
        struct_name, // Pass struct_name for downcast in singleton wrapper
    );

    let controller_dependencies: Vec<(Ident, TokenStream)> = dependencies
        .fields
        .iter()
        .map(|(field_name, _full_type, lookup_token_expr)| {
            let dep_field_name = Ident::new(&format!("{}_dep", field_name), field_name.span());
            (dep_field_name, lookup_token_expr.clone())
        })
        .collect();

    Ok((
        wrapper,
        MetadataInfo {
            struct_name: controller_name,
            dependencies: controller_dependencies,
        },
    ))
}

fn generate_field_resolutions(dependencies: &DependencyInfo) -> (Vec<TokenStream>, Vec<Ident>) {
    let mut resolutions = Vec::new();
    let mut field_names = Vec::new();

    // Process each field individually (since lookup_token is now TokenStream, we can't group easily)
    for (field_name, full_type, lookup_token_expr) in &dependencies.fields {
        let field_name_str = field_name.to_string();

        let resolution = quote! {
            let #field_name: #full_type = {
                let __lookup_token = #lookup_token_expr;
                let provider = self.dependencies
                    .get(&__lookup_token)
                    .unwrap_or_else(|| panic!("Missing dependency '{}'", __lookup_token));

                let any_box = provider.execute(vec![], Some(&req)).await;

                *any_box.downcast::<#full_type>()
                    .unwrap_or_else(|_| panic!(
                        "Failed to downcast '{}' to {}",
                        __lookup_token,
                        stringify!(#full_type)
                    ))
            };
        };

        resolutions.push(resolution);
        field_names.push(field_name.clone());
    }

    (resolutions, field_names)
}

// NOTE: Old deduplication logic was removed since TokenStream can't be easily compared
// If deduplication is needed in the future, we would need to:
// 1. Store type information separately from the runtime token generation
// 2. Group by static type information at compile time
// 3. Generate runtime token expressions for each grouped field

fn generate_method_call(method: &ImplItemFn, marker_params: &[MarkerParam]) -> Result<TokenStream> {
    let method_name = &method.sig.ident;
    let is_async = method.sig.asyncness.is_some();

    let mut call_args = vec![quote! { req }];

    for marker_param in marker_params {
        let param_name = &marker_param.param_name;
        call_args.push(quote! { #param_name });
    }

    let call = quote! { controller.#method_name(#(#call_args),*) };

    Ok(if is_async {
        quote! { #call.await }
    } else {
        call
    })
}

fn generate_marker_params_extraction(
    marker_params: &[MarkerParam],
) -> Result<(Vec<TokenStream>, Option<TokenStream>)> {
    let mut extractions = Vec::new();
    let mut body_dto_token_stream = None;

    for marker_param in marker_params {
        match marker_param.marker_name.as_str() {
            "body" => {
                let dto_type_ident = &marker_param.type_ident;
                body_dto_token_stream = Some(create_extract_body_dto_token_stream(dto_type_ident)?);
                extractions.push(extract_body_from_param(marker_param)?);
            }
            "query" => {
                extractions.push(extract_query_from_param(marker_param)?);
            }
            "param" => {
                extractions.push(extract_path_param_from_param(marker_param)?);
            }
            _ => {}
        }
    }

    Ok((extractions, body_dto_token_stream))
}

fn generate_controller_wrapper_code(
    controller_name: &Ident,
    controller_token: &str,
    full_route_path: &str,
    http_method: &str,
    field_resolutions: &[TokenStream],
    struct_instantiation: &TokenStream,
    method_call: &TokenStream,
    enhancers: &HashMap<String, Vec<TokenStream>>,
    marker_params_extraction: &[TokenStream],
    body_dto_token_stream: &Option<TokenStream>,
    scope: crate::shared::scope_parser::ControllerScope,
    struct_name: &Ident,
) -> TokenStream {
    use crate::shared::scope_parser::ControllerScope;

    match scope {
        ControllerScope::Singleton => generate_singleton_controller_wrapper(
            controller_name,
            controller_token,
            full_route_path,
            http_method,
            method_call,
            enhancers,
            marker_params_extraction,
            body_dto_token_stream,
            struct_name, // Pass struct name for downcast
        ),
        ControllerScope::Request => generate_request_controller_wrapper(
            controller_name,
            controller_token,
            full_route_path,
            http_method,
            field_resolutions,
            struct_instantiation,
            method_call,
            enhancers,
            marker_params_extraction,
            body_dto_token_stream,
        ),
    }
}

// Singleton controller (stores Arc<ControllerInstance> created at startup)
fn generate_singleton_controller_wrapper(
    controller_name: &Ident,
    controller_token: &str,
    full_route_path: &str,
    http_method: &str,
    method_call: &TokenStream,
    enhancers: &HashMap<String, Vec<TokenStream>>,
    marker_params_extraction: &[TokenStream],
    body_dto_token_stream: &Option<TokenStream>,
    struct_name: &Ident, // Need this for downcast type
) -> TokenStream {
    let binding = Vec::new();
    let use_guards = enhancers.get("guards").unwrap_or(&binding);
    let interceptors = enhancers.get("interceptors").unwrap_or(&binding);
    let pipes = enhancers.get("pipes").unwrap_or(&binding);

    let body_dto_stream = if let Some(token_stream) = body_dto_token_stream {
        token_stream.clone()
    } else {
        quote! { None }
    };

    quote! {
        struct #controller_name {
            // Singleton: Store the pre-created controller instance!
            instance: ::std::sync::Arc<dyn ::std::any::Any + Send + Sync>,
        }

        #[::toni::async_trait]
        impl ::toni::traits_helpers::ControllerTrait for #controller_name {
            async fn execute(
                &self,
                req: ::toni::http_helpers::HttpRequest,
            ) -> Box<dyn ::toni::http_helpers::IntoResponse<Response = ::toni::http_helpers::HttpResponse> + Send> {
                // NO dependency resolution here!
                // NO controller instantiation here!
                // Just extract parameters and call the handler on the pre-existing instance

                #(#marker_params_extraction)*

                // Downcast the Arc<dyn Any> to the actual controller type
                let controller = self.instance
                    .downcast_ref::<#struct_name>()
                    .expect("Failed to downcast controller instance");

                let result = #method_call;
                Box::new(result)
            }

            fn get_method(&self) -> ::toni::http_helpers::HttpMethod {
                ::toni::http_helpers::HttpMethod::from_string(#http_method).unwrap()
            }

            fn get_path(&self) -> String {
                #full_route_path.to_string()
            }

            fn get_token(&self) -> String {
                #controller_token.to_string()
            }

            fn get_guards(&self) -> Vec<::std::sync::Arc<dyn ::toni::traits_helpers::Guard>> {
                vec![#(#use_guards),*]
            }

            fn get_interceptors(&self) -> Vec<::std::sync::Arc<dyn ::toni::traits_helpers::Interceptor>> {
                vec![#(#interceptors),*]
            }

            fn get_pipes(&self) -> Vec<::std::sync::Arc<dyn ::toni::traits_helpers::Pipe>> {
                vec![#(#pipes),*]
            }

            fn get_body_dto(&self, _req: &::toni::http_helpers::HttpRequest) -> Option<Box<dyn ::toni::traits_helpers::validate::Validatable>> {
                #body_dto_stream
            }
        }
    }
}

// Request-scoped controller (creates instance per request)
fn generate_request_controller_wrapper(
    controller_name: &Ident,
    controller_token: &str,
    full_route_path: &str,
    http_method: &str,
    field_resolutions: &[TokenStream],
    struct_instantiation: &TokenStream,
    method_call: &TokenStream,
    enhancers: &HashMap<String, Vec<TokenStream>>,
    marker_params_extraction: &[TokenStream],
    body_dto_token_stream: &Option<TokenStream>,
) -> TokenStream {
    let binding = Vec::new();
    let use_guards = enhancers.get("guards").unwrap_or(&binding);
    let interceptors = enhancers.get("interceptors").unwrap_or(&binding);
    let pipes = enhancers.get("pipes").unwrap_or(&binding);

    let body_dto_stream = if let Some(token_stream) = body_dto_token_stream {
        token_stream.clone()
    } else {
        quote! { None }
    };

    quote! {
        struct #controller_name {
            dependencies: ::toni::FxHashMap<
                String,
                ::std::sync::Arc<Box<dyn ::toni::traits_helpers::ProviderTrait>>
            >,
        }

        #[::toni::async_trait]
        impl ::toni::traits_helpers::ControllerTrait for #controller_name {
            async fn execute(
                &self,
                req: ::toni::http_helpers::HttpRequest,
            ) -> Box<dyn ::toni::http_helpers::IntoResponse<Response = ::toni::http_helpers::HttpResponse> + Send> {
                #(#field_resolutions)*
                #(#marker_params_extraction)*
                #struct_instantiation

                let result = #method_call;
                Box::new(result)
            }

            fn get_method(&self) -> ::toni::http_helpers::HttpMethod {
                ::toni::http_helpers::HttpMethod::from_string(#http_method).unwrap()
            }

            fn get_path(&self) -> String {
                #full_route_path.to_string()
            }

            fn get_token(&self) -> String {
                #controller_token.to_string()
            }

            fn get_guards(&self) -> Vec<::std::sync::Arc<dyn ::toni::traits_helpers::Guard>> {
                vec![#(#use_guards),*]
            }

            fn get_interceptors(&self) -> Vec<::std::sync::Arc<dyn ::toni::traits_helpers::Interceptor>> {
                vec![#(#interceptors),*]
            }

            fn get_pipes(&self) -> Vec<::std::sync::Arc<dyn ::toni::traits_helpers::Pipe>> {
                vec![#(#pipes),*]
            }

            fn get_body_dto(&self, _req: &::toni::http_helpers::HttpRequest) -> Option<Box<dyn ::toni::traits_helpers::validate::Validatable>> {
                #body_dto_stream
            }
        }
    }
}

fn generate_manager(
    struct_name: &Ident,
    singleton_metadata: Vec<MetadataInfo>,
    request_metadata: Vec<MetadataInfo>,
    dependencies: &DependencyInfo,
    scope: crate::shared::scope_parser::ControllerScope,
    was_explicit: bool,
) -> TokenStream {
    use crate::shared::scope_parser::ControllerScope;

    match scope {
        ControllerScope::Singleton => generate_singleton_manager(
            struct_name,
            singleton_metadata,
            request_metadata,
            dependencies,
            was_explicit,
        ),
        ControllerScope::Request => {
            // Request-scoped controllers don't need elevation logic
            generate_request_manager(struct_name, request_metadata, dependencies)
        }
    }
}

// Singleton manager - creates controller instance AT STARTUP
// OR elevates to Request scope if dependencies require it
fn generate_singleton_manager(
    struct_name: &Ident,
    singleton_metadata: Vec<MetadataInfo>,
    request_metadata: Vec<MetadataInfo>,
    dependencies: &DependencyInfo,
    was_explicit: bool,
) -> TokenStream {
    let manager_name = Ident::new(&format!("{}Manager", struct_name), struct_name.span());
    let struct_token = struct_name.to_string();

    let dependency_token_exprs: Vec<&TokenStream> = dependencies
        .fields
        .iter()
        .map(|(_, _full_type, lookup_token_expr)| lookup_token_expr)
        .collect();

    let unique_tokens: Vec<_> = dependency_token_exprs
        .iter()
        .map(|token_expr| token_expr)
        .collect();

    // Generate field resolutions AT STARTUP (no HttpRequest available)
    let field_resolutions = dependencies
        .fields
        .iter()
        .map(|(field_name, full_type, lookup_token_expr)| {
            let field_name_str = field_name.to_string();
            quote! {
                let #field_name: #full_type = {
                    let __lookup_token = #lookup_token_expr;
                    let provider = dependencies
                        .get(&__lookup_token)
                        .unwrap_or_else(|| panic!("Missing dependency '{}'", __lookup_token));

                    let any_box = provider.execute(vec![], None).await;

                    *any_box.downcast::<#full_type>()
                        .unwrap_or_else(|_| panic!(
                            "Failed to downcast '{}' to {}",
                            __lookup_token,
                            stringify!(#full_type)
                        ))
                };
            }
        })
        .collect::<Vec<_>>();

    let field_names: Vec<_> = dependencies
        .fields
        .iter()
        .map(|(field_name, _, _)| field_name.clone())
        .collect();

    // Generate initializers for owned fields
    let owned_field_inits: Vec<_> = dependencies
        .owned_fields
        .iter()
        .map(|(field_name, field_type, default_expr)| {
            if let Some(expr) = default_expr {
                quote! { #field_name: #expr }
            } else {
                quote! { #field_name: <#field_type>::default() }
            }
        })
        .collect();

    // Create controller wrappers with the shared Arc'd instance (for Singleton mode)
    let controller_wrapper_creations: Vec<_> = singleton_metadata
        .iter()
        .map(|metadata| {
            let controller_name = &metadata.struct_name;
            let controller_token = controller_name.to_string();

            quote! {
                controllers.insert(
                    #controller_token.to_string(),
                    ::std::sync::Arc::new(
                        Box::new(#controller_name {
                            instance: controller_instance.clone(),
                        }) as Box<dyn ::toni::traits_helpers::ControllerTrait>
                    )
                );
            }
        })
        .collect();

    // Generate scope checking code to determine if we need to elevate to Request scope
    let scope_check_code = if dependencies.fields.is_empty() {
        // No dependencies - definitely Singleton
        quote! { let needs_elevation = false; }
    } else {
        let dep_checks: Vec<_> = dependencies
            .fields
            .iter()
            .map(|(_, _, lookup_token_expr)| {
                quote! {
                    {
                        let __lookup_token = #lookup_token_expr;
                        if let Some(provider) = dependencies.get(&__lookup_token) {
                            if matches!(provider.get_scope(), ::toni::ProviderScope::Request) {
                                request_deps.push(__lookup_token);
                            }
                        }
                    }
                }
            })
            .collect();

        quote! {
            // Check if any dependency is Request-scoped
            let mut request_deps: Vec<String> = Vec::new();
            #(#dep_checks)*
            let needs_elevation = !request_deps.is_empty();
        }
    };

    // Generate warning messages based on strategy
    let warning_code = if was_explicit {
        // Case 3: User explicitly set singleton, but we need to elevate
        quote! {
            if needs_elevation {
                eprintln!("⚠️  WARNING: Controller '{}' explicitly declared as 'singleton'", #struct_token);
                eprintln!("    but depends on Request-scoped provider(s): {:?}", request_deps);
                eprintln!("    The controller will be Request-scoped. Change to:");
                eprintln!("    #[controller_struct(scope = \"request\", pub struct {} {{ ... }})]", #struct_token);
            }
        }
    } else {
        // Case 1: Default scope (implicit singleton), elevating to request
        quote! {
            if needs_elevation {
                eprintln!("⚠️  INFO: Controller '{}' automatically elevated to Request scope", #struct_token);
                eprintln!("    due to Request-scoped provider(s): {:?}", request_deps);
                eprintln!("    To silence this message, explicitly set:");
                eprintln!("    #[controller_struct(scope = \"request\", pub struct {} {{ ... }})]", #struct_token);
            }
        }
    };

    // Generate controller instances for Request-scoped (used if elevation happens)
    let request_controller_instances: Vec<_> = request_metadata
        .iter()
        .map(|metadata| {
            let controller_name = &metadata.struct_name;
            let controller_token = controller_name.to_string();

            quote! {
                (
                    #controller_token.to_string(),
                    ::std::sync::Arc::new(
                        Box::new(#controller_name {
                            dependencies: dependencies.clone(),
                        }) as Box<dyn ::toni::traits_helpers::ControllerTrait>
                    )
                )
            }
        })
        .collect();

    quote! {
        pub struct #manager_name;

        #[::toni::async_trait]
        impl ::toni::traits_helpers::Controller for #manager_name {
            async fn get_all_controllers(
                &self,
                dependencies: &::toni::FxHashMap<
                    String,
                    ::std::sync::Arc<Box<dyn ::toni::traits_helpers::ProviderTrait>>
                >,
            ) -> ::toni::FxHashMap<
                String,
                ::std::sync::Arc<Box<dyn ::toni::traits_helpers::ControllerTrait>>
            > {
                let mut controllers = ::toni::FxHashMap::default();

                // CHECK IF ELEVATION TO REQUEST SCOPE IS NEEDED
                #scope_check_code

                // EMIT WARNINGS BASED ON STRATEGY
                #warning_code

                // BRANCH: Use Request-scoped logic if elevation needed, otherwise Singleton
                if needs_elevation {
                    // ELEVATED TO REQUEST SCOPE - use Request-scoped wrappers
                    #(
                        let (key, value): (String, ::std::sync::Arc<Box<dyn ::toni::traits_helpers::ControllerTrait>>) = #request_controller_instances;
                        controllers.insert(key, value);
                    )*
                } else {
                    // TRUE SINGLETON - create instance once at startup
                    // RESOLVE DEPENDENCIES AT STARTUP
                    #(#field_resolutions)*

                    // CREATE CONTROLLER INSTANCE AT STARTUP
                    let controller_instance: ::std::sync::Arc<dyn ::std::any::Any + Send + Sync> = ::std::sync::Arc::new(#struct_name {
                        #(#field_names,)*  // Injected dependencies
                        #(#owned_field_inits),*  // Owned fields with defaults
                    });

                    // CREATE ALL HANDLER WRAPPERS THAT SHARE THE SAME ARC
                    #(#controller_wrapper_creations)*
                }

                controllers
            }

            fn get_name(&self) -> String {
                #struct_token.to_string()
            }

            fn get_token(&self) -> String {
                #struct_token.to_string()
            }

            fn get_dependencies(&self) -> Vec<String> {
                vec![#(#unique_tokens),*]
            }
        }
    }
}

// Request manager - stores dependencies, creates instance per request
fn generate_request_manager(
    struct_name: &Ident,
    metadata_list: Vec<MetadataInfo>,
    dependencies: &DependencyInfo,
) -> TokenStream {
    let manager_name = Ident::new(&format!("{}Manager", struct_name), struct_name.span());
    let struct_token = struct_name.to_string();

    let dependency_token_exprs: Vec<&TokenStream> = dependencies
        .fields
        .iter()
        .map(|(_, _full_type, lookup_token_expr)| lookup_token_expr)
        .collect();

    let unique_tokens: Vec<_> = dependency_token_exprs
        .iter()
        .map(|token_expr| token_expr)
        .collect();

    let controller_instances: Vec<_> = metadata_list
        .iter()
        .map(|metadata| {
            let controller_name = &metadata.struct_name;
            let controller_token = controller_name.to_string();

            quote! {
                (
                    #controller_token.to_string(),
                    ::std::sync::Arc::new(
                        Box::new(#controller_name {
                            dependencies: dependencies.clone(),
                        }) as Box<dyn ::toni::traits_helpers::ControllerTrait>
                    )
                )
            }
        })
        .collect();

    quote! {
        pub struct #manager_name;

        #[::toni::async_trait]
        impl ::toni::traits_helpers::Controller for #manager_name {
            async fn get_all_controllers(
                &self,
                dependencies: &::toni::FxHashMap<
                    String,
                    ::std::sync::Arc<Box<dyn ::toni::traits_helpers::ProviderTrait>>
                >,
            ) -> ::toni::FxHashMap<
                String,
                ::std::sync::Arc<Box<dyn ::toni::traits_helpers::ControllerTrait>>
            > {
                let mut controllers = ::toni::FxHashMap::default();

                #(
                    let (key, value): (String, ::std::sync::Arc<Box<dyn ::toni::traits_helpers::ControllerTrait>>) = #controller_instances;
                    controllers.insert(key, value);
                )*

                controllers
            }

            fn get_name(&self) -> String {
                #struct_token.to_string()
            }

            fn get_token(&self) -> String {
                #struct_token.to_string()
            }

            fn get_dependencies(&self) -> Vec<String> {
                vec![#(#unique_tokens),*]
            }
        }
    }
}

fn capitalize_first(s: String) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
